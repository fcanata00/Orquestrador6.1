#!/usr/bin/env bash
# binpkg - Unified CLI frontend for LFS toolchain scripts
# Version: 1.0
# Location: /usr/bin/binpkg (recommended)
set -Eeuo pipefail
IFS=$'\n\t'

# ---- Configuration (override via env) ----
: "${MODULE_PATHS:=/usr/bin:/mnt/lfs/usr/bin}"
: "${LOG_DIR:=/var/log/lfs}"
: "${STATE_DIR:=/var/lib/lfs/binpkg}"
: "${SILENT:=false}"
: "${DRY_RUN:=false}"
: "${RETRIES:=3}"
export MODULE_PATHS LOG_DIR STATE_DIR SILENT DRY_RUN RETRIES

mkdir -p "$LOG_DIR" "$STATE_DIR"

# basic logging helpers
_log(){ if [ "$SILENT" != "true" ]; then printf "[binpkg] %s\n" "$*"; fi; printf "%s %s\n" "$(date -u +%FT%TZ)" "$*" >> "$LOG_DIR/binpkg.log"; }
_warn(){ if [ "$SILENT" != "true" ]; then printf "[binpkg][WARN] %s\n" "$*"; fi; printf "%s WARN %s\n" "$(date -u +%FT%TZ)" "$*" >> "$LOG_DIR/binpkg.log"; }
_err(){ if [ "$SILENT" != "true" ]; then printf "[binpkg][ERROR] %s\n" "$*" >&2; fi; printf "%s ERROR %s\n" "$(date -u +%FT%TZ)" "$*" >> "$LOG_DIR/binpkg.log"; }

# find script in MODULE_PATHS
_find_module(){
  local name="$1"
  IFS=':' read -r -a paths <<< "$MODULE_PATHS"
  for p in "${paths[@]}"; do
    [ -x "$p/$name" ] && { printf "%s\n" "$p/$name"; return 0; }
    [ -f "$p/$name" ] && { printf "%s\n" "$p/$name"; return 0; }
  done
  return 1
}

# spinner for long tasks
_spinner_start(){
  local msg="$1"
  local pidfile="$STATE_DIR/spinner.pid"
  ( 
    local i=0; local sp='|/-\'
    while true; do
      i=$(( (i+1) %4 ))
      printf "\r\033[1;34m%s \033[0m%s" "${sp:i:1}" "$msg"
      sleep 0.12
    done
  ) &
  echo $! > "$pidfile"
}

_spinner_stop(){
  local pidfile="$STATE_DIR/spinner.pid"
  if [ -f "$pidfile" ]; then
    kill "$(cat "$pidfile")" >/dev/null 2>&1 || true
    rm -f "$pidfile"
    printf "\r\033[1;32mâœ”\033[0m Done\n"
  fi
}

# simple progress bar for downloads (percentage) - prints single-line bar
_progress_bar(){
  # usage: _progress_bar <percent> <label>
  local pct=$1; shift || true
  local label="${*:-}"
  local filled=$((pct/2))
  local empty=$((50-filled))
  printf "\r["
  for i in $(seq 1 $filled); do printf "\033[1;32m#\033[0m"; done
  for i in $(seq 1 $empty); do printf "-"; done
  printf "] %3d%% %s" "$pct" "$label"
  if [ "$pct" -ge 100 ]; then printf "\n"; fi
}

# wrapper to call module subcommand
_call_module(){
  local module="$1"; shift
  local mpath
  if ! mpath=$(_find_module "$module" 2>/dev/null || true); then
    _err "Module $module not found in MODULE_PATHS ($MODULE_PATHS)"
    return 1
  fi
  # source if it's a shell library, else execute
  if head -n1 "$mpath" 2>/dev/null | grep -qE '^#!'; then
    # try run as executable with args
    if [ "$DRY_RUN" = "true" ]; then _log "[DRY-RUN] Would run $mpath $*"; return 0; fi
    "$mpath" "$@"
    return $?
  else
    # source and call exported function if provided
    if [ "$DRY_RUN" = "true" ]; then _log "[DRY-RUN] Would source $mpath and call $*"; return 0; fi
    # shellcheck source=/dev/null
    source "$mpath" || true
    local func="$1"; shift || true
    if [ -n "$func" ] && type "$func" >/dev/null 2>&1; then
      "$func" "$@"; return $?
    elif type "main" >/dev/null 2>&1; then
      main "$@"; return $?
    elif type "run" >/dev/null 2>&1; then
      run "$@"; return $?
    else
      "$mpath" "$func" "$@"; return $?
    fi
  fi
}

# helper: download with progress (tries to use curl or wget; simulates progress if none)
_dl_with_progress(){
  local url="$1"; local out="$2"
  if [ "$DRY_RUN" = "true" ]; then _log "[DRY-RUN] Would download $url -> $out"; return 0; fi
  if command -v curl >/dev/null 2>&1; then
    if command -v pv >/dev/null 2>&1; then
      # try to get content-length
      local clen=$(curl -sI "$url" | awk '/Content-Length/ {print $2}' | tr -d '\r' || true)
      if [ -n "$clen" ]; then
        curl -sL "$url" | pv -s "$clen" > "$out"
        _progress_bar 100 "$(basename "$out")"
        return 0
      fi
    fi
    _spinner_start "Downloading $(basename "$out")"
    if curl -fL -o "$out" "$url"; then _spinner_stop; _progress_bar 100 "$(basename "$out")"; return 0; else _spinner_stop; _err "curl failed"; return 1; fi
  elif command -v wget >/dev/null 2>&1; then
    _spinner_start "Downloading $(basename "$out")"
    if wget -q -O "$out" "$url"; then _spinner_stop; _progress_bar 100 "$(basename "$out")"; return 0; else _spinner_stop; _err "wget failed"; return 1; fi
  else
    for p in 10 30 60 80 95 100; do sleep 0.12; _progress_bar $p "$(basename "$out")"; done
    touch "$out"
    _log "Saved simulated $out (no curl/wget)"
    return 0
  fi
}

# Map high-level commands to modules
_usage(){
  cat <<'EOF'
binpkg - Unified LFS CLI

Usage examples:
  binpkg dl fetch <url> <out>          # download with progress (alias to download.sh)
  binpkg dl meta <pkg>                 # download sources from metafile
  binpkg build pkg <name>              # build a package (calls build.sh)
  binpkg build stage <1|2|3>           # build stage via bootstrap.sh
  binpkg install pkg <name>            # install from cache or build (create_install.sh)
  binpkg rm pkg <name>                 # uninstall a package
  binpkg update check <pkg>            # check for updates (update.sh)
  binpkg find <name>                   # find pkg (find_pkg.sh)
  binpkg info <name>                   # show info (info_pkg.sh)
  binpkg doctor scan                   # run diagnostics (doctor.sh)
  binpkg commit add "msg" <files...>   # commit (commit.sh)
  binpkg diff files <f1> <f2>          # create diff (create_diff.sh)
  binpkg help                          # show this help
Global flags:
  --dry-run   simulate actions
  --quiet     reduce output
EOF
}

# top-level dispatcher
if [ "${BASH_SOURCE[0]}" = "$0" ]; then
  if [ "$#" -lt 1 ]; then _usage; exit 2; fi
  # global flags
  while [ "$#" -gt 0 ] && [[ "$1" == --* ]]; do
    case "$1" in
      --dry-run) DRY_RUN=true; shift;;
      --quiet|--silent) SILENT=true; shift;;
      *) break;;
    esac
  done

  cmd="$1"; shift || true
  case "$cmd" in
    dl|download)
      sub="$1"; shift || true
      case "$sub" in
        fetch)
          url="$1"; out="$2"; shift 2 || true
          [ -z "$url" ] && { _err "url required"; exit 2; }
          out="${out:-/var/cache/lfs/$(basename "$url")}"
          _dl_with_progress "$url" "$out"; exit $? ;;
        meta)
          pkg="$1"; shift || true
          _call_module "download.sh" "fetch_from_metafile" "$pkg" || _err "download meta fallback"; exit $? ;;
        *) _usage; exit 2;;
      esac ;;
    build)
      sub="$1"; shift || true
      case "$sub" in
        pkg) name="$1"; shift || true; [ -z "$name" ] && { _err "pkg name required"; exit 2; }; _call_module "build.sh" "run" "$name"; exit $? ;;
        stage) stage="$1"; shift || true; _call_module "bootstrap.sh" "--create" "$stage"; exit $? ;;
        *) _usage; exit 2;;
      esac ;;
    install)
      sub="$1"; shift || true
      case "$sub" in
        pkg) name="$1"; shift || true; _call_module "create_install.sh" "package" "$name"; exit $? ;;
        multi) shift; _call_module "create_install.sh" "package-multi" "$@"; exit $? ;;
        *) _usage; exit 2;;
      esac ;;
    rm|uninstall)
      sub="$1"; shift || true
      case "$sub" in
        pkg) name="$1"; shift || true; _call_module "uninstall.sh" "remove" "$name"; exit $? ;;
        orphans) _call_module "uninstall.sh" "remove-orphans" ; exit $? ;;
        *) _usage; exit 2;;
      esac ;;
    update)
      sub="$1"; shift || true
      case "$sub" in
        check) _call_module "update.sh" "--check" "$1"; exit $? ;;
        apply) _call_module "update.sh" "--apply" "$1"; exit $? ;;
        upgrade) _call_module "update.sh" "--upgrade" "$@"; exit $? ;;
        *) _usage; exit 2;;
      esac ;;
    find)
      name="$1"; shift || true
      _call_module "find_pkg.sh" "--search" "$name"; exit $? ;;
    info)
      name="$1"; shift || true
      _call_module "info_pkg.sh" "--pkg" "$name"; exit $? ;;
    doctor)
      sub="$1"; shift || true
      case "$sub" in
        scan) _call_module "doctor.sh" "--scan"; exit $? ;;
        pkg) _call_module "doctor.sh" "--pkg" "$1"; exit $? ;;
        *) _usage; exit 2;;
      esac ;;
    commit)
      sub="$1"; shift || true
      case "$sub" in
        add) msg="$1"; shift; _call_module "commit.sh" "--add" "$msg" "$@"; exit $? ;;
        push) _call_module "commit.sh" "--commit" "$@"; exit $? ;;
        branch) _call_module "commit.sh" "--branch" "$1"; exit $? ;;
        tag) _call_module "commit.sh" "--tag" "$1"; exit $? ;;
        *) _usage; exit 2;;
      esac ;;
    diff)
      sub="$1"; shift || true
      case "$sub" in
        files) _call_module "create_diff.sh" "--files" "$1" "$2"; exit $? ;;
        dirs) _call_module "create_diff.sh" "--dirs" "$1" "$2"; exit $? ;;
        stage) _call_module "create_diff.sh" "--stage" "$1" "$2"; exit $? ;;
        *) _usage; exit 2;;
      esac ;;
    help|-h|--help) _usage; exit 0 ;;
    *) _usage; exit 2 ;;
  esac
fi

# export helpers for other scripts
export -f _find_module _call_module _dl_with_progress _progress_bar _spinner_start _spinner_stop
